<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JS Tetris</title>
    <style>
        /* CSS 스타일 */
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #282c34; /* 배경색 */
            font-family: Arial, sans-serif;
            color: white;
            flex-direction: column;
        }

        #game-container {
            display: flex;
            gap: 20px;
            background-color: #000000; /* 게임 영역 배경 */
            padding: 10px;
            border: 5px solid #61dafb; /* 테두리 */
            box-shadow: 0 0 20px rgba(97, 218, 251, 0.8);
        }

        #grid {
            display: grid;
            /* JavaScript에서 생성될 격자 크기 */
            border: 2px solid #333;
        }

        .cell {
            width: 25px; /* 한 칸의 크기 */
            height: 25px;
            background-color: #111; /* 빈 칸 색상 */
            border: 1px solid #000;
            box-sizing: border-box;
        }

        /* 테트리스 블록 색상 */
        .color-I { background-color: cyan; border: 1px solid #00cccc; }
        .color-O { background-color: yellow; border: 1px solid #cccc00; }
        .color-T { background-color: purple; border: 1px solid #800080; }
        .color-S { background-color: green; border: 1px solid #008000; }
        .color-Z { background-color: red; border: 1px solid #800000; }
        .color-J { background-color: blue; border: 1px solid #000080; }
        .color-L { background-color: orange; border: 1px solid #cc8400; }

        #sidebar {
            width: 150px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #next-piece {
            margin-bottom: 20px;
            padding: 10px;
            border: 2px solid white;
            text-align: center;
        }

        #next-grid {
            display: grid;
        }

        .next-cell {
            width: 20px;
            height: 20px;
            background-color: #111;
            border: 1px solid #000;
            box-sizing: border-box;
        }

        #score-board, #instructions {
            margin-top: 10px;
            padding: 10px;
            border: 2px solid white;
            width: 100%;
            box-sizing: border-box;
        }

        #instructions p {
            font-size: 12px;
            line-height: 1.4;
        }

        h1 {
            color: #61dafb;
            margin-bottom: 20px;
        }
        
        #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            display: none; /* 초기에는 숨김 */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }

        #game-over-screen h2 {
            font-size: 3em;
            color: red;
        }

        #game-over-screen button {
            padding: 10px 20px;
            font-size: 1.2em;
            cursor: pointer;
            margin-top: 20px;
        }

    </style>
</head>
<body>

    <h1>JS Tetris</h1>

    <div id="game-container">
        <div id="grid">
            </div>
        <div id="sidebar">
            <div id="score-board">
                <h2>점수</h2>
                <div id="score">0</div>
            </div>
            <div id="next-piece">
                <h2>다음 블록</h2>
                <div id="next-grid">
                    </div>
            </div>
            <div id="instructions">
                <h2>조작법</h2>
                <p>← / →: 이동</p>
                <p>↑: 회전</p>
                <p>↓: 소프트 드롭</p>
                <p>Space: 하드 드롭</p>
            </div>
        </div>
    </div>
    
    <div id="game-over-screen">
        <h2>GAME OVER</h2>
        <p>최종 점수: <span id="final-score">0</span></p>
        <button onclick="startGame()">다시 시작</button>
    </div>

    <script>
        // JavaScript 로직
        const GRID_WIDTH = 10;
        const GRID_HEIGHT = 20;
        const CELL_SIZE = 25; // CSS .cell 크기와 동일해야 함

        const gridElement = document.getElementById('grid');
        const nextGridElement = document.getElementById('next-grid');
        const scoreElement = document.getElementById('score');
        const gameOverScreen = document.getElementById('game-over-screen');
        const finalScoreElement = document.getElementById('final-score');

        // 테트리스 블록 (테트로미노) 정의
        const TETROMINOS = {
            'I': {
                matrix: [
                    [0, 0, 0, 0],
                    [1, 1, 1, 1],
                    [0, 0, 0, 0],
                    [0, 0, 0, 0],
                ],
                color: 'color-I'
            },
            'O': {
                matrix: [
                    [1, 1],
                    [1, 1],
                ],
                color: 'color-O'
            },
            'T': {
                matrix: [
                    [0, 1, 0],
                    [1, 1, 1],
                    [0, 0, 0],
                ],
                color: 'color-T'
            },
            'S': {
                matrix: [
                    [0, 1, 1],
                    [1, 1, 0],
                    [0, 0, 0],
                ],
                color: 'color-S'
            },
            'Z': {
                matrix: [
                    [1, 1, 0],
                    [0, 1, 1],
                    [0, 0, 0],
                ],
                color: 'color-Z'
            },
            'J': {
                matrix: [
                    [1, 0, 0],
                    [1, 1, 1],
                    [0, 0, 0],
                ],
                color: 'color-J'
            },
            'L': {
                matrix: [
                    [0, 0, 1],
                    [1, 1, 1],
                    [0, 0, 0],
                ],
                color: 'color-L'
            }
        };

        let playfield; // 게임 판의 상태 (2차원 배열)
        let tetromino; // 현재 떨어지는 블록
        let nextTetromino; // 다음 블록
        let score;
        let gameLoopInterval;
        let isGameOver;

        // 게임판 초기화 함수
        function initPlayfield() {
            playfield = [];
            for (let r = 0; r < GRID_HEIGHT; r++) {
                playfield.push(new Array(GRID_WIDTH).fill(0)); // 0은 빈 칸을 의미
            }
        }

        // DOM 격자 생성 및 스타일 설정
        function createGridElements() {
            gridElement.style.gridTemplateColumns = `repeat(${GRID_WIDTH}, ${CELL_SIZE}px)`;
            gridElement.style.gridTemplateRows = `repeat(${GRID_HEIGHT}, ${CELL_SIZE}px)`;
            gridElement.innerHTML = '';
            for (let i = 0; i < GRID_WIDTH * GRID_HEIGHT; i++) {
                const cell = document.createElement('div');
                cell.classList.add('cell');
                gridElement.appendChild(cell);
            }

            // 다음 블록 미리보기 영역 초기화 (가장 큰 4x4에 맞춤)
            nextGridElement.style.gridTemplateColumns = `repeat(4, 20px)`;
            nextGridElement.style.gridTemplateRows = `repeat(4, 20px)`;
            nextGridElement.innerHTML = '';
            for (let i = 0; i < 16; i++) {
                const cell = document.createElement('div');
                cell.classList.add('next-cell');
                nextGridElement.appendChild(cell);
            }
        }

        // 테트로미노를 무작위로 생성하는 함수
        function generateTetromino() {
            const keys = Object.keys(TETROMINOS);
            const name = keys[Math.floor(Math.random() * keys.length)];
            const piece = TETROMINOS[name];
            
            // 시작 위치 계산
            const matrixSize = piece.matrix.length;
            const startCol = Math.floor(GRID_WIDTH / 2) - Math.floor(matrixSize / 2);

            return {
                name: name,
                matrix: piece.matrix,
                color: piece.color,
                row: 0, // 시작 행
                col: startCol // 시작 열
            };
        }

        // 다음 블록 가져오기 (초기 호출 시 첫 블록 생성)
        function getNextTetromino() {
            if (!nextTetromino) {
                nextTetromino = generateTetromino();
            }
            tetromino = nextTetromino;
            nextTetromino = generateTetromino();
        }

        // 블록을 회전시키는 함수
        function rotateMatrix(matrix) {
            const N = matrix.length;
            const result = matrix.map((row, i) => row.map((_, j) => matrix[N - 1 - j][i]));
            return result;
        }

        // 충돌 검사
        function isValidMove(matrix, row, col) {
            for (let r = 0; r < matrix.length; r++) {
                for (let c = 0; c < matrix[r].length; c++) {
                    if (matrix[r][c] !== 0) { // 블록이 있는 경우
                        const newRow = row + r;
                        const newCol = col + c;

                        // 경계 밖이거나 이미 채워진 칸과 충돌하는 경우
                        if (newCol < 0 || newCol >= GRID_WIDTH || newRow >= GRID_HEIGHT || (newRow >= 0 && playfield[newRow][newCol] !== 0)) {
                            return false;
                        }
                    }
                }
            }
            return true;
        }

        // 블록을 게임 판에 고정
        function placeTetromino() {
            const matrix = tetromino.matrix;
            const color = tetromino.name;

            for (let r = 0; r < matrix.length; r++) {
                for (let c = 0; c < matrix[r].length; c++) {
                    if (matrix[r][c] !== 0) {
                        const row = tetromino.row + r;
                        const col = tetromino.col + c;

                        if (row < 0) { // 블록이 화면 상단 밖에서 고정되면 게임 오버
                            isGameOver = true;
                            return;
                        }
                        playfield[row][col] = color;
                    }
                }
            }
            // 고정 후 라인 제거 시도
            clearLines();
        }

        // 라인 제거 및 점수 계산
        function clearLines() {
            let linesCleared = 0;

            for (let r = GRID_HEIGHT - 1; r >= 0; r--) {
                if (playfield[r].every(cell => cell !== 0)) { // 줄이 가득 찬 경우
                    linesCleared++;
                    // 해당 줄을 제거하고 윗줄들을 한 칸씩 내립니다.
                    for (let rr = r; rr > 0; rr--) {
                        playfield[rr] = playfield[rr - 1];
                    }
                    playfield[0] = new Array(GRID_WIDTH).fill(0); // 맨 윗줄은 빈 칸으로 채웁니다.
                    r++; // 현재 줄이 내려왔으므로 다시 검사합니다.
                }
            }

            // 점수 업데이트 (테트리스 점수 규칙 단순화)
            if (linesCleared > 0) {
                score += [0, 100, 300, 500, 800][linesCleared]; // 1줄, 2줄, 3줄, 4줄
            }
        }

        // 게임 상태를 화면에 그리는 함수
        function draw() {
            // 1. 플레이 필드 그리기
            for (let r = 0; r < GRID_HEIGHT; r++) {
                for (let c = 0; c < GRID_WIDTH; c++) {
                    const cellIndex = r * GRID_WIDTH + c;
                    const cell = gridElement.children[cellIndex];
                    const cellValue = playfield[r][c];

                    // 모든 클래스 초기화
                    cell.className = 'cell';

                    if (cellValue !== 0) {
                        cell.classList.add(`color-${cellValue}`);
                    }
                }
            }

            // 2. 현재 떨어지는 블록 그리기
            if (tetromino) {
                const matrix = tetromino.matrix;
                for (let r = 0; r < matrix.length; r++) {
                    for (let c = 0; c < matrix[r].length; c++) {
                        if (matrix[r][c] !== 0) {
                            const gridRow = tetromino.row + r;
                            const gridCol = tetromino.col + c;

                            if (gridRow >= 0 && gridRow < GRID_HEIGHT && gridCol >= 0 && gridCol < GRID_WIDTH) {
                                const cellIndex = gridRow * GRID_WIDTH + gridCol;
                                const cell = gridElement.children[cellIndex];
                                // 기존의 고정된 블록 위에 덧그릴 때 색깔이 유지되도록 클래스 추가
                                cell.classList.add(tetromino.color);
                            }
                        }
                    }
                }
            }
            
            // 3. 점수 업데이트
            scoreElement.textContent = score;

            // 4. 다음 블록 미리보기 그리기
            drawNextPiece();
        }
        
        // 다음 블록 미리보기 그리기
        function drawNextPiece() {
            nextGridElement.innerHTML = ''; // 초기화
            const matrix = nextTetromino.matrix;
            const matrixSize = matrix.length;
            
            nextGridElement.style.gridTemplateColumns = `repeat(${matrixSize}, 20px)`;
            nextGridElement.style.gridTemplateRows = `repeat(${matrixSize}, 20px)`;

            for (let r = 0; r < matrixSize; r++) {
                for (let c = 0; c < matrixSize; c++) {
                    const cell = document.createElement('div');
                    cell.classList.add('next-cell');
                    if (matrix[r][c] !== 0) {
                        cell.classList.add(nextTetromino.color);
                    }
                    nextGridElement.appendChild(cell);
                }
            }
        }

        // 게임 루프 (블록을 아래로 떨어뜨림)
        function gameLoop() {
            if (isGameOver) {
                clearInterval(gameLoopInterval);
                gameOverScreen.style.display = 'flex';
                finalScoreElement.textContent = score;
                return;
            }

            if (!tetromino) {
                getNextTetromino();
                if (!isValidMove(tetromino.matrix, tetromino.row, tetromino.col)) {
                    isGameOver = true;
                    gameLoop(); // 게임 오버 처리
                    return;
                }
            }

            // 블록을 한 칸 아래로 이동 시도
            if (isValidMove(tetromino.matrix, tetromino.row + 1, tetromino.col)) {
                tetromino.row++;
            } else {
                // 이동 실패 (바닥 또는 다른 블록과 충돌)
                placeTetromino();
                tetromino = null; // 다음 블록 생성 준비
            }

            draw();
        }

        // 키보드 이벤트 핸들러
        document.addEventListener('keydown', (e) => {
            if (isGameOver) return;
            if (!tetromino) return;

            if (e.key === 'ArrowLeft') {
                if (isValidMove(tetromino.matrix, tetromino.row, tetromino.col - 1)) {
                    tetromino.col--;
                }
            } else if (e.key === 'ArrowRight') {
                if (isValidMove(tetromino.matrix, tetromino.row, tetromino.col + 1)) {
                    tetromino.col++;
                }
            } else if (e.key === 'ArrowDown') {
                // 소프트 드롭 (바로 아래로 이동)
                if (isValidMove(tetromino.matrix, tetromino.row + 1, tetromino.col)) {
                    tetromino.row++;
                    score += 1; // 소프트 드롭 점수
                    draw();
                }
            } else if (e.key === 'ArrowUp') {
                // 회전
                const rotated = rotateMatrix(tetromino.matrix);
                if (isValidMove(rotated, tetromino.row, tetromino.col)) {
                    tetromino.matrix = rotated;
                } else {
                    // 벽차기 (Wall Kick) 구현 생략 - 간단한 버전
                }
            } else if (e.key === ' ') {
                // 하드 드롭 (바닥까지 한번에)
                while (isValidMove(tetromino.matrix, tetromino.row + 1, tetromino.col)) {
                    tetromino.row++;
                    score += 2; // 하드 드롭 점수
                }
                placeTetromino();
                tetromino = null;
                // 하드 드롭 후 바로 게임 루프 실행하여 다음 블록 생성
                gameLoop(); 
            }
            draw();
        });

        // 게임 시작/재시작 함수
        function startGame() {
            initPlayfield();
            createGridElements();
            score = 0;
            tetromino = null;
            nextTetromino = null;
            isGameOver = false;
            gameOverScreen.style.display = 'none';
            
            // 초기 다음 블록 설정 (게임 루프에서 첫 블록이 생성되도록)
            nextTetromino = generateTetromino(); 
            drawNextPiece();
            
            // 기존 인터벌 제거
            if (gameLoopInterval) {
                clearInterval(gameLoopInterval);
            }
            // 게임 루프 500ms(0.5초) 간격으로 실행
            gameLoopInterval = setInterval(gameLoop, 500);
            draw(); // 초기 화면 그리기
        }

        // 페이지 로드 시 게임 시작
        window.onload = startGame;
    </script>
</body>
</html>
