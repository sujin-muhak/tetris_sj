<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JS Tetris</title>
    <style>
        /* CSS 스타일 (이전과 동일) */
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #282c34; /* 배경색 */
            font-family: Arial, sans-serif;
            color: white;
            flex-direction: column;
        }

        #game-container {
            display: flex;
            gap: 20px;
            background-color: #000000; /* 게임 영역 배경 */
            padding: 10px;
            border: 5px solid #61dafb; /* 테두리 */
            box-shadow: 0 0 20px rgba(97, 218, 251, 0.8);
        }

        #grid {
            display: grid;
            /* JavaScript에서 생성될 격자 크기 */
            border: 2px solid #333;
        }

        .cell {
            width: 25px; /* 한 칸의 크기 */
            height: 25px;
            background-color: #111; /* 빈 칸 색상 */
            border: 1px solid #000;
            box-sizing: border-box;
        }

        /* 테트리스 블록 색상 */
        .color-I { background-color: cyan; border: 1px solid #00cccc; }
        .color-O { background-color: yellow; border: 1px solid #cccc00; }
        .color-T { background-color: purple; border: 1px solid #800080; }
        .color-S { background-color: green; border: 1px solid #008000; }
        .color-Z { background-color: red; border: 1px solid #800000; }
        .color-J { background-color: blue; border: 1px solid #000080; }
        .color-L { background-color: orange; border: 1px solid #cc8400; }

        #sidebar {
            width: 150px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #next-piece {
            margin-bottom: 20px;
            padding: 10px;
            border: 2px solid white;
            text-align: center;
        }

        #next-grid {
            display: grid;
        }

        .next-cell {
            width: 20px;
            height: 20px;
            background-color: #111;
            border: 1px solid #000;
            box-sizing: border-box;
        }

        #score-board, #instructions {
            margin-top: 10px;
            padding: 10px;
            border: 2px solid white;
            width: 100%;
            box-sizing: border-box;
        }
        
        /* 이름 표시 추가 */
        #player-name {
            font-size: 1.2em;
            color: #ffcc00; /* 강조 색상 */
            margin-bottom: 5px;
        }

        #instructions p {
            font-size: 12px;
            line-height: 1.4;
        }

        h1 {
            color: #61dafb;
            margin-bottom: 20px;
        }
        
        #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            display: none; /* 초기에는 숨김 */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }

        #game-over-screen h2 {
            font-size: 3em;
            color: red;
        }

        #game-over-screen button {
            padding: 10px 20px;
            font-size: 1.2em;
            cursor: pointer;
            margin-top: 20px;
        }

        /* 이름 입력 화면 스타일 */
        #name-input-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
        }

        #name-input-screen input {
            padding: 10px;
            margin: 10px 0;
            font-size: 1.2em;
            border: none;
            text-align: center;
        }

        #name-input-screen button {
            padding: 10px 20px;
            font-size: 1.2em;
            cursor: pointer;
            margin-top: 10px;
        }

    </style>
</head>
<body>

    <h1>JS Tetris</h1>

    <div id="game-container">
        <div id="grid">
            </div>
        <div id="sidebar">
            <div id="score-board">
                <div id="player-name">Player</div> <h2>점수</h2>
                <div id="score">0</div>
            </div>
            <div id="next-piece">
                <h2>다음 블록</h2>
                <div id="next-grid">
                    </div>
            </div>
            <div id="instructions">
                <h2>조작법</h2>
                <p>← / →: 이동</p>
                <p>↑: 회전</p>
                <p>↓: 소프트 드롭</p>
                <p>Space: 하드 드롭</p>
            </div>
        </div>
    </div>
    
    <div id="game-over-screen">
        <h2>GAME OVER</h2>
        <p><span id="final-player-name">플레이어</span>님의 최종 점수: <span id="final-score">0</span></p> <button onclick="showNameInput()">다시 시작</button> </div>

    <div id="name-input-screen">
        <h2>이름을 입력하세요</h2>
        <input type="text" id="username-input" placeholder="여기에 이름을 입력">
        <button onclick="startGameFromInput()">게임 시작</button>
    </div>

    <script>
        // JavaScript 로직
        const GRID_WIDTH = 10;
        const GRID_HEIGHT = 20;
        const CELL_SIZE = 25; // CSS .cell 크기와 동일해야 함

        const gridElement = document.getElementById('grid');
        const nextGridElement = document.getElementById('next-grid');
        const scoreElement = document.getElementById('score');
        const playerNameElement = document.getElementById('player-name'); // 이름 표시 DOM
        const gameOverScreen = document.getElementById('game-over-screen');
        const finalScoreElement = document.getElementById('final-score');
        const finalPlayerNameElement = document.getElementById('final-player-name'); // 게임 오버 시 이름 표시 DOM
        const nameInputScreen = document.getElementById('name-input-screen');
        const usernameInput = document.getElementById('username-input');

        // 게임 상태 변수
        let playfield; 
        let tetromino; 
        let nextTetromino; 
        let score;
        let gameLoopInterval;
        let isGameOver;
        let username = "Player"; // 사용자 이름을 저장할 변수

        // 테트리스 블록 (테트로미노) 정의 (생략 - 이전 코드와 동일)
        const TETROMINOS = {
            'I': { matrix: [[0, 0, 0, 0], [1, 1, 1, 1], [0, 0, 0, 0], [0, 0, 0, 0]], color: 'color-I' },
            'O': { matrix: [[1, 1], [1, 1]], color: 'color-O' },
            'T': { matrix: [[0, 1, 0], [1, 1, 1], [0, 0, 0]], color: 'color-T' },
            'S': { matrix: [[0, 1, 1], [1, 1, 0], [0, 0, 0]], color: 'color-S' },
            'Z': { matrix: [[1, 1, 0], [0, 1, 1], [0, 0, 0]], color: 'color-Z' },
            'J': { matrix: [[1, 0, 0], [1, 1, 1], [0, 0, 0]], color: 'color-J' },
            'L': { matrix: [[0, 0, 1], [1, 1, 1], [0, 0, 0]], color: 'color-L' }
        };

        // --- 핵심 함수 (이전과 동일) ---
        function initPlayfield() { /* ... */
            playfield = [];
            for (let r = 0; r < GRID_HEIGHT; r++) {
                playfield.push(new Array(GRID_WIDTH).fill(0));
            }
        }
        function createGridElements() { /* ... */
            gridElement.style.gridTemplateColumns = `repeat(${GRID_WIDTH}, ${CELL_SIZE}px)`;
            gridElement.style.gridTemplateRows = `repeat(${GRID_HEIGHT}, ${CELL_SIZE}px)`;
            gridElement.innerHTML = '';
            for (let i = 0; i < GRID_WIDTH * GRID_HEIGHT; i++) {
                const cell = document.createElement('div');
                cell.classList.add('cell');
                gridElement.appendChild(cell);
            }
            nextGridElement.style.gridTemplateColumns = `repeat(4, 20px)`;
            nextGridElement.style.gridTemplateRows = `repeat(4, 20px)`;
            nextGridElement.innerHTML = '';
            for (let i = 0; i < 16; i++) {
                const cell = document.createElement('div');
                cell.classList.add('next-cell');
                nextGridElement.appendChild(cell);
            }
        }
        function generateTetromino() { /* ... */
            const keys = Object.keys(TETROMINOS);
            const name = keys[Math.floor(Math.random() * keys.length)];
            const piece = TETROMINOS[name];
            const matrixSize = piece.matrix.length;
            const startCol = Math.floor(GRID_WIDTH / 2) - Math.floor(matrixSize / 2);
            return { name: name, matrix: piece.matrix, color: piece.color, row: 0, col: startCol };
        }
        function getNextTetromino() { /* ... */
            if (!nextTetromino) { nextTetromino = generateTetromino(); }
            tetromino = nextTetromino;
            nextTetromino = generateTetromino();
        }
        function rotateMatrix(matrix) { /* ... */
            const N = matrix.length;
            const result = matrix.map((row, i) => row.map((_, j) => matrix[N - 1 - j][i]));
            return result;
        }
        function isValidMove(matrix, row, col) { /* ... */
            for (let r = 0; r < matrix.length; r++) {
                for (let c = 0; c < matrix[r].length; c++) {
                    if (matrix[r][c] !== 0) {
                        const newRow = row + r;
                        const newCol = col + c;
                        if (newCol < 0 || newCol >= GRID_WIDTH || newRow >= GRID_HEIGHT || (newRow >= 0 && playfield[newRow][newCol] !== 0)) {
                            return false;
                        }
                    }
                }
            }
            return true;
        }
        function placeTetromino() { /* ... */
            const matrix = tetromino.matrix;
            const color = tetromino.name;
            for (let r = 0; r < matrix.length; r++) {
                for (let c = 0; c < matrix[r].length; c++) {
                    if (matrix[r][c] !== 0) {
                        const row = tetromino.row + r;
                        const col = tetromino.col + c;
                        if (row < 0) { isGameOver = true; return; }
                        playfield[row][col] = color;
                    }
                }
            }
            clearLines();
        }
        function clearLines() { /* ... */
            let linesCleared = 0;
            for (let r = GRID_HEIGHT - 1; r >= 0; r--) {
                if (playfield[r].every(cell => cell !== 0)) {
                    linesCleared++;
                    for (let rr = r; rr > 0; rr--) {
                        playfield[rr] = playfield[rr - 1];
                    }
                    playfield[0] = new Array(GRID_WIDTH).fill(0);
                    r++; 
                }
            }
            if (linesCleared > 0) {
                score += [0, 100, 300, 500, 800][linesCleared];
            }
        }
        function draw() { /* ... */
            // 1. 플레이 필드 그리기
            for (let r = 0; r < GRID_HEIGHT; r++) {
                for (let c = 0; c < GRID_WIDTH; c++) {
                    const cellIndex = r * GRID_WIDTH + c;
                    const cell = gridElement.children[cellIndex];
                    const cellValue = playfield[r][c];
                    cell.className = 'cell';
                    if (cellValue !== 0) {
                        cell.classList.add(`color-${cellValue}`);
                    }
                }
            }

            // 2. 현재 떨어지는 블록 그리기
            if (tetromino) {
                const matrix = tetromino.matrix;
                for (let r = 0; r < matrix.length; r++) {
                    for (let c = 0; c < matrix[r].length; c++) {
                        if (matrix[r][c] !== 0) {
                            const gridRow = tetromino.row + r;
                            const gridCol = tetromino.col + c;
                            if (gridRow >= 0 && gridRow < GRID_HEIGHT && gridCol >= 0 && gridCol < GRID_WIDTH) {
                                const cellIndex = gridRow * GRID_WIDTH + gridCol;
                                const cell = gridElement.children[cellIndex];
                                cell.classList.add(tetromino.color);
                            }
                        }
                    }
                }
            }
            
            // 3. 점수 및 이름 업데이트
            scoreElement.textContent = score;
            playerNameElement.textContent = username; // 이름 업데이트

            // 4. 다음 블록 미리보기 그리기
            drawNextPiece();
        }
        function drawNextPiece() { /* ... */
            nextGridElement.innerHTML = '';
            const matrix = nextTetromino.matrix;
            const matrixSize = matrix.length;
            
            nextGridElement.style.gridTemplateColumns = `repeat(${matrixSize}, 20px)`;
            nextGridElement.style.gridTemplateRows = `repeat(${matrixSize}, 20px)`;

            for (let r = 0; r < matrixSize; r++) {
                for (let c = 0; c < matrixSize; c++) {
                    const cell = document.createElement('div');
                    cell.classList.add('next-cell');
                    if (matrix[r][c] !== 0) {
                        cell.classList.add(nextTetromino.color);
                    }
                    nextGridElement.appendChild(cell);
                }
            }
        }
        function gameLoop() { /* ... */
            if (isGameOver) {
                clearInterval(gameLoopInterval);
                gameOverScreen.style.display = 'flex';
                finalScoreElement.textContent = score;
                finalPlayerNameElement.textContent = username; // 게임 오버 시 이름 표시
                return;
            }

            if (!tetromino) {
                getNextTetromino();
                if (!isValidMove(tetromino.matrix, tetromino.row, tetromino.col)) {
                    isGameOver = true;
                    gameLoop(); 
                    return;
                }
            }

            if (isValidMove(tetromino.matrix, tetromino.row + 1, tetromino.col)) {
                tetromino.row++;
            } else {
                placeTetromino();
                tetromino = null;
            }

            draw();
        }
        document.addEventListener('keydown', (e) => { /* ... */
            if (isGameOver || !tetromino) return;

            if (e.key === 'ArrowLeft') {
                if (isValidMove(tetromino.matrix, tetromino.row, tetromino.col - 1)) {
                    tetromino.col--;
                }
            } else if (e.key === 'ArrowRight') {
                if (isValidMove(tetromino.matrix, tetromino.row, tetromino.col + 1)) {
                    tetromino.col++;
                }
            } else if (e.key === 'ArrowDown') {
                if (isValidMove(tetromino.matrix, tetromino.row + 1, tetromino.col)) {
                    tetromino.row++;
                    score += 1;
                    draw();
                }
            } else if (e.key === 'ArrowUp') {
                const rotated = rotateMatrix(tetromino.matrix);
                if (isValidMove(rotated, tetromino.row, tetromino.col)) {
                    tetromino.matrix = rotated;
                }
            } else if (e.key === ' ') {
                while (isValidMove(tetromino.matrix, tetromino.row + 1, tetromino.col)) {
                    tetromino.row++;
                    score += 2;
                }
                placeTetromino();
                tetromino = null;
                gameLoop(); 
            }
            draw();
        });
        
        // --- 이름 입력 및 게임 시작 관련 함수 추가/수정 ---

        // 게임을 실제로 시작하는 로직 (이름 입력 후 호출됨)
        function startGame() {
            initPlayfield();
            createGridElements();
            score = 0;
            tetromino = null;
            nextTetromino = null;
            isGameOver = false;
            gameOverScreen.style.display = 'none';
            nameInputScreen.style.display = 'none'; // 입력 화면 숨김

            // 플레이어 이름 업데이트 (점수판)
            playerNameElement.textContent = username;

            nextTetromino = generateTetromino(); 
            drawNextPiece();
            
            if (gameLoopInterval) {
                clearInterval(gameLoopInterval);
            }
            gameLoopInterval = setInterval(gameLoop, 500);
            draw();
        }

        // 이름 입력 화면을 보여주는 함수
        function showNameInput() {
            gameOverScreen.style.display = 'none';
            nameInputScreen.style.display = 'flex';
            usernameInput.focus();
        }

        // 이름 입력 후 게임 시작 버튼 클릭 시 호출
        function startGameFromInput() {
            const inputName = usernameInput.value.trim();
            // 이름이 비어있으면 기본값 사용
            username = inputName === "" ? "Player" : inputName;
            startGame();
        }

        // 페이지 로드 시 이름 입력 화면 표시
        window.onload = showNameInput;
        
        // 이름 입력 필드에서 엔터 키를 누르면 시작하도록 추가
        usernameInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                startGameFromInput();
            }
        });

    </script>
</body>
</html>
